---
title: "R Analyses and Figures for Manuscript"
author: "Zachary Rowson and Kelly E Carstens"
date: "6/7/2022"
output: 
  html_document:
    
    code_folding: hide
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE)
library(gabi)
library(data.table)
library(DT)
library(sjPlot)
library(gridExtra)
library(viridis)
library(grid)
library(ggupset)
library(matrixStats)

```

## Introduction

This document will contain all analyses and figures produced in R to be included in the manuscript. Note the script was originally written by Zachary Rowson and updated by Kelly Carstens for publication.

```{r, load-necessary-data}

# Raw data, endpoint data, and row objects for tcplfit2
load("./Data/Padilla_DNT60_lmr0_w_egid.Rdata")
load("./Data/Padilla_DNT60_mc0.rda")
load("./Data/Padilla_DNT60_mc0_n.rda")
load("./Data/Padilla_DNT60_rows_n.rda")

# Results of curve fitting
#load("./Data/Padilla_DNT60_tcplfits.rda") # file not located; Zach Rowson needs to regenerate this rda
load("./Data/Padilla_DNT60_tcpl_out.Rdata")
tcpl_out.dt <- as.data.table(DNT60_tcpl_out)

# Summarizing results of curve-fitting
load("./Data/Padilla_DNT60_Strong Effectors by Endpoint.Rdata")
load("./Data/Padilla_DNT60_BMC ranges.Rdata") # This data needs to be recompiled

# Results of literature review
load("./Data/Padilla_DNT60_Behavioral LOELs.Rdata")
load("./Data/Literature Review Summary.Rdata")
load("./Data/Literature Review Concentrations and Activity.Rdata")
load("./Data/Literature Review LOELs and Dev LOELs.Rdata") 
```

### Example Locomotor Response Data

```{r, edit-CPF-name}
lmr0.egid[cpid=="Chlorpyrifos (ethyl)", cpid := "Chlorpyrifos"]
```

```{r, CPF-SA-timeSeries, include=FALSE}
chemical <- "Chlorpyrifos"

# Units
unit.t = "min"
unit.mov = "cm"
unit.conc = paste0("\U03BC","M")
prsp = "SA"
no.A = 10

# Extract chemical data
group <- unique(lmr0.egid[cpid == chemical, egid])

## Identify movement columns of interest
t.cols <- grep("vt", names(lmr0.egid), value = TRUE)
cols <- t.cols[(no.A+1):length(t.cols)]
A.cols <- t.cols[!(t.cols%in%cols)]

## extract data to be plotted, exclude acclimation
to.fit <- lmr0.egid[cpid==chemical | (wllt=="v" & egid==group), -A.cols, with=FALSE]

# create appropriate axes titles for plots
label.y <- "Speed"

# Format data for plotting

## calculate mean and 50% CIs for each vector column by concentration group, excluding concentration
exclude.A <- t.cols[!(t.cols%in%A.cols)]
means <- to.fit[, lapply(.SD, function(col) mean(col,na.rm=T)),
                .SDcols = exclude.A,
                by = conc]

## calculate CI's for transformed values then transform back
shift <- 1
logCIs <- to.fit[, lapply(.SD, function(x) log10(x+shift)), .SDcols=exclude.A, by=conc][
  , lapply(.SD, function(x) t.test(x,conf.level=0.50)$conf.int), .SDcols=exclude.A, by=conc]
CIs <- logCIs[, lapply(.SD, function(x) (10^x)-shift), by=conc][,lapply(.SD, function(col) abs(diff(col))/2), .SDcols=exclude.A, by=conc]

## elongate means and CIs data, and join
means_long <- data.table::melt(means, id.vars = "conc", variable.name = "t", value.name = "mean")
means_long[, t := sub("vt","",t)]
CIs_long <- data.table::melt(CIs, id.vars = "conc", variable.name = "t", value.name = "CI")
CIs_long[, t := sub("vt","",t)]
stats <- means_long[CIs_long, on = c("conc","t")][, conc := as.factor(conc)]
stats[, t := as.numeric(t)]

# create standard error of mean estimates by time period and plot as ribbons or error bars

# plot time-series data

## create title, x- and y-axis titles, legend labels, and legend title
title <- paste0("Sample Averaged Time-Series for ", chemical)
title.t <- paste0("Time (",unit.t,")")
title.mean <- paste0("Mean ", label.y, " (",unit.mov,"/",unit.t,")")
conc.n <- to.fit[wllq==1, .N, by=.(conc)][order(conc)]
legend.labels <- paste0(conc.n$conc, ", n=", conc.n$N)

title.legend <- paste0("Concentration (", unit.conc, ")")

## get better colors for plotting
N <- length(unique(to.fit[,conc]))
colors <- viridis::viridis(N)

## create x-axis breaks and labels
m <- as.integer(max(means_long[,t]))
x.breaks <- seq(from=no.A,to=m,by=10)
x.labels1 <- 2*seq(from=no.A,to=m,by=10)
x.labels2 <- x.labels1 - 2
x.labels <- paste(x.labels2, x.labels1, sep="-")

## plot
CPFSAplot <- ggplot() +
          geom_point(data = stats, aes(x=t, y=mean, color=as.factor(conc))) +
          geom_line(data = stats, aes(x=t, y=mean, color=conc, group=conc)) +
          scale_x_continuous(breaks = x.breaks, labels = x.labels) +
          scale_color_manual(values = colors, labels=legend.labels) +
          geom_ribbon(data = stats,
                      aes(x=t, ymax=mean+CI, ymin=mean-CI, group=conc, fill=conc),
                      alpha = 0.25) +
          geom_rect(aes(xmin=10,xmax=30,ymin=-1.25,ymax=-0.5) ,fill="white", color="black") +
          geom_rect(aes(xmin=30,xmax=50,ymin=-1.25,ymax=-0.5) ,fill="black", color="black") +
          annotate("text", x=c(20,40), y=rep(-0.875,2), color=c("black","white"), label=c("Light Phase","Dark Phase"), size=3) +
          scale_fill_manual(values = colors, labels=legend.labels) +
          labs(title = title, subtitle = "Acclimation Period Excluded: 50% Confidence Bands",
               x = title.t, y = title.mean, color = title.legend) +
          guides(fill = "none") +
          theme_bw() +
          theme(text = element_text(size = 14))

CPFSAplot
```

### Example tcpl Curve-Fit

```{r, example-curve-fit, warning=FALSE, include=FALSE}
# tcplfit <- tcplfits_n[["Chlorpyrifos"]][["avgS_L"]]
# tcplfit[["plot"]]
# summary <- subset( tcplfit[["summary"]], select = -c(conc,resp) )
# summary
```

## Results

### Appearance of Endpoint Data

```{r, large-ctrl-sample-SAplot}
# Time Series for Fluoxetine vehicle control

# Units
unit.t = "2 min"
unit.mov = "cm"
unit.conc = paste0("\U03BC","M")
no.A = 10


# Identify movement columns of interest and extract
t.cols <- grep("vt", names(lmr0.egid), value = TRUE)
cols <- t.cols[(no.A+1):length(t.cols)]
A.cols <- t.cols[!(t.cols%in%cols)]
to.fit <- lmr0.egid[wllt=="v", -A.cols, with=FALSE]

# Melt data and designate Light and Dark time periods
to.fit_melt <- melt(to.fit[,-"egid"], id.vars = names(to.fit)[1:9], variable.name = "t", value.name = "speed")
to.fit_melt[, t := as.factor( gsub("vt","",t) )]
to.fit_melt[t%in%11:30, phase := "Light"]
to.fit_melt[t%in%31:50, phase := "Dark"]

# Create title, x- and y-axis titles, legend labels, and legend title
title.t <- paste0("Time (",unit.t,")")
label.y <- "Speed"
title.mean <- paste0(label.y, " (",unit.mov,"/",unit.t,")")

title.legend <- "Experimental Phase"

## Create x-axis breaks and labels
m <- 50
x.breaks <- c(11, 20, 30, 40, 50)
x.labels1 <- 2*seq(from=no.A,to=m,by=10)
x.labels2 <- x.labels1 - 2
x.labels <- paste(x.labels2, x.labels1, sep="-")

# Printing of graphic isn't working very well so insert new breaks to make space for edges
x.breaks <- c(5, x.breaks, 55)
x.labels <- c("a", x.labels, "b")

## plot
DNT60_VC_Plot <- ggplot(to.fit_melt) +
          geom_boxplot(aes(x=t,y=speed,fill=phase)) +
          scale_x_discrete(breaks = x.breaks, labels = x.labels) +
          scale_fill_manual(values=c("darkgrey","white")) +
          labs(x = title.t, y = title.mean, fill = "Experimental Phase") +
          theme_bw() +
          theme(text = element_text(size = 26))
DNT60_VC_Plot
```

#### Figure 2 (all controls- overlay transform): Typical Unexposed, Raw Movement Data: The Effect of Transformation on Distributions of Endpoint Data

```{r, large-ctrl-sample-SAplot}

# Time Series for Fluoxetine vehicle control

# Units
unit.t = "2 min"
unit.mov = "cm"
unit.conc = paste0("\U03BC","M")
no.A = 10


# Identify movement columns of interest and extract
t.cols <- grep("vt", names(lmr0.egid), value = TRUE)
cols <- t.cols[(no.A+1):length(t.cols)]
A.cols <- t.cols[!(t.cols%in%cols)]
to.fit <- lmr0.egid[wllt=="v", -A.cols, with=FALSE]

# Melt data and designate Light and Dark time periods
to.fit_melt <- melt(to.fit[,-"egid"], id.vars = names(to.fit)[1:9], variable.name = "t", value.name = "speed")
to.fit_melt[, t := as.factor( gsub("vt","",t) )]
to.fit_melt[t%in%11:30, phase := "Light"]
to.fit_melt[t%in%31:50, phase := "Dark"]

# Create title, x- and y-axis titles, legend labels, and legend title
title.t <- paste0("Time (",unit.t,")")
label.y <- "Speed"
title.mean <- paste0(label.y, " (",unit.mov,"/",unit.t,")")

title.legend <- "Experimental Phase"

## Create x-axis breaks and labels
m <- 50
x.breaks <- c(11, 20, 30, 40, 50)
x.labels1 <- 2*seq(from=no.A,to=m,by=10)
x.labels2 <- x.labels1 - 2
x.labels <- paste(x.labels2, x.labels1, sep="-")

# Printing of graphic isn't working very well so insert new breaks to make space for edges
x.breaks <- c(5, x.breaks, 55)
x.labels <- c("a", x.labels, "b")

## plot
DNT60_VC_Plot <- ggplot(to.fit_melt) +
          geom_boxplot(aes(x=t,y=speed,fill=phase)) +
          scale_x_discrete(breaks = x.breaks, labels = x.labels) +
          scale_fill_manual(values=c("darkgrey","white")) +
          labs(x = title.t, y = title.mean, fill = "Experimental Phase") +
          theme_bw() +
          theme(text = element_text(size = 26))
DNT60_VC_Plot

```

```{r, calculate-speed-data-for-smpl, message = FALSE}
# Raw endpoint data for Fluoxetine vehicle control

sample_endpoints <- data.table::copy(mc0)

sample_endpoints[c("AUC_L","AUC_D","AUC_T")] = NULL
for (i in 1:13) {
  sample_endpoints[[i]][, endp := names(sample_endpoints)[i]]
}

endp.data <- do.call('rbind', sample_endpoints)
max.conc <- max( endp.data[cpid=="Fluoxetine", conc] )

raw_stats <- endp.data[wllt=="v" | (conc==max.conc & cpid=="Fluoxetine")][endp == "avgS_L"][, .(mean=mean(rval,na.rm=T),median=median(rval,na.rm=T), sd=sd(rval,na.rm=T)), by=.(conc)]
raw_stats_long <- data.table::melt(raw_stats, id.vars = "conc", variable.name = "stat")
raw_stats_long <- raw_stats_long[!stat %in% "median",]

FlxAvgS_LPlot <- ggplot(endp.data[wllt=="v" | (conc==max.conc & cpid=="Fluoxetine")][endp == "avgS_L"]) +
  geom_density(aes(x=rval, fill=as.factor(conc), color = as.factor(conc)), alpha = 0.5) +
  theme_bw() +
  theme(text = element_text(size = 26)) +
  scale_color_manual(values = colors[c(1,5)]) +
  scale_fill_manual(values = colors[c(1,5)]) +
  labs(color = paste0("Concentration (", unit.conc, ")"),
       fill = paste0("Concentration (", unit.conc, ")"),
       linetype = "",
       x = "Raw Endpoint Value",
       y = "Density")

FlxAvgS_LPlot <- FlxAvgS_LPlot + 
                  geom_vline(data = raw_stats_long, aes(xintercept=value, linetype=stat), color = colors[c(1,5,1,5)], size=1) +
                  #scale_linetype_discrete(labels = c("Mean","Median")) +
                  #scale_y_continuous(labels = c("0.0","0.1","0.2","0.3","")) +
                  labs(color = paste0("Concentration (", unit.conc, ")"),
                       fill = paste0("Concentration (", unit.conc, ")"),
                       linetype = "",
                       x = "Raw Endpoint Value",
                       y = NULL)
FlxAvgS_LPlot
legend <- cowplot::get_legend(FlxAvgS_LPlot)

FlxAvgS_LPlot <- FlxAvgS_LPlot + theme(legend.position="none")
```

```{r, calculate-speed-data-for-smpl_N, message = FALSE}
sample_endpoints_n <- lapply(mc0_n, function(list) {
  table <- list[[1]]
})

sample_endpoints_n[c("AUC_L","AUC_D","AUC_T")] = NULL
for (i in 1:13) {
  sample_endpoints_n[[i]][, endp := names(sample_endpoints_n)[i]]
}

endp.data_n <- do.call('rbind', sample_endpoints_n)

trans_stats <- endp.data_n[wllt=="v" | (conc==max.conc & cpid=="Fluoxetine")][endp == "avgS_L"][, .(mean=mean(rval,na.rm=T),median=median(rval,na.rm=T), sd=sd(rval,na.rm=T)), by=.(conc)]
trans_stats_long <- data.table::melt(trans_stats, id.vars = "conc", variable.name = "stat")
trans_stats_long
trans_stats_long <- trans_stats_long[!stat %in% "sd",]

FlxAvgS_LPlot_n <-ggplot(endp.data_n[wllt=="v" | (conc==max.conc & cpid=="Fluoxetine")][endp == "avgS_L"]) +
  geom_density(aes(x=rval, fill=as.factor(conc), color = as.factor(conc)), alpha = 0.5) +
  theme_bw() +
  theme(text = element_text(size = 26)) +
  scale_color_manual(values = colors[c(1,5)]) +
  scale_fill_manual(values = colors[c(1,5)]) +
  labs(color = paste0("Concentration (", unit.conc, ")"),
       fill = paste0("Concentration (", unit.conc, ")"),
       linetype = "",
       x = "Transformed Endpoint Value",
       y = NULL)

FlxAvgS_LPlot_n <- FlxAvgS_LPlot_n + 
                    geom_vline(data = trans_stats_long, aes(xintercept=value, linetype=stat), color = colors[c(1,5,1,5)], size=1) +
                    scale_linetype_discrete(labels = c("Mean","Median")) +
                    labs(color = paste0("Concentration (", unit.conc, ")"),
                         fill = paste0("Concentration (", unit.conc, ")"),
                         linetype = "",
                         x = "Transformed Endpoint Value",
                         y = NULL)

FlxAvgS_LPlot_n <- FlxAvgS_LPlot_n + theme(legend.position="none")
FlxAvgS_LPlot_n
```

```{r, plot-Flx-data, fig.dim=c(19,13), message = FALSE}
FlxEndpPlots <- cowplot::plot_grid(FlxAvgS_LPlot, FlxAvgS_LPlot_n,
                   labels = list("B","C"), label_size = 24)
FlxEndpPlots1 <- cowplot::plot_grid(FlxEndpPlots, legend, rel_widths = c(3, 1))
FlxPlots <- cowplot:::plot_grid(DNT60_VC_Plot, FlxEndpPlots1,
                    labels = list("A"), label_size = 24,
                    ncol = 1)
FlxPlots

# ggsave(FlxPlots, file='figures/Figure2_ALL_ctrl.png',
#        width=20,
#        height=15)
```

Kelly E Carstens modified the figure for manuscript to show non-transformed versus transformed. 
```{r, calculate-speed-data-for-smpl_N, message = FALSE}
sample_endpoints_n <- lapply(mc0_n, function(list) {
  table <- list[[1]]
})

sample_endpoints_n[c("AUC_L","AUC_D","AUC_T")] = NULL
for (i in 1:13) {
  sample_endpoints_n[[i]][, endp := names(sample_endpoints_n)[i]]
}

endp.data_n <- do.call('rbind', sample_endpoints_n)

endp.data_n$transform <- "Transformed"
endp.data$transform <- "Non-transformed"

endp.data_all <- rbind(endp.data, endp.data_n)


FlxAvgS_LPlot_n_0 <-ggplot(endp.data_all[wllt=="v",][endp == "avgS_L"]) +
  geom_density(aes(x=rval, fill=as.factor(transform), color = as.factor(transform)), alpha = 0.5) +
  theme_bw() +
  xlim(-2,10)+
  ylim(0,1.8)+
  theme(text = element_text(size = 26)) +
  scale_color_manual(values = colors[c(1,5)]) +
  scale_fill_manual(values = colors[c(1,5)]) +
  labs(color = "",
       fill = "",
       linetype = "",
       x = "Endpoint Value",
       y = NULL)+
  ggtitle("Vehicle controls, AvgS-L")
FlxAvgS_LPlot_n_0
legend <- cowplot::get_legend(FlxAvgS_LPlot_n_0)

FlxAvgS_LPlot_n_0 <- FlxAvgS_LPlot_n_0 + theme(legend.position="none")


FlxAvgS_LPlot_n_max <-ggplot(endp.data_all[conc==max.conc & cpid=="Fluoxetine"][endp == "avgS_L"]) +
  geom_density(aes(x=rval, fill=as.factor(transform), color = as.factor(transform)), alpha = 0.5) +
  theme_bw() +
  xlim(-2,10)+
  ylim(0,1.8)+
  theme(text = element_text(size = 26)) +
  scale_color_manual(values = colors[c(1,5)]) +
  scale_fill_manual(values = colors[c(1,5)]) +
  labs(
    color = "",
    fill = "",
       linetype = "",
       x = "Endpoint Value",
       y = NULL)+
  ggtitle(paste0("Fluoxetine (4uM), AvgS-L"))
FlxAvgS_LPlot_n_max

FlxAvgS_LPlot_n_max <- FlxAvgS_LPlot_n_max + theme(legend.position="none")
```

```{r, plot-Flx-data, fig.dim=c(19,13), message = FALSE}
FlxEndpPlots <- cowplot::plot_grid(FlxAvgS_LPlot_n_0, FlxAvgS_LPlot_n_max,
                   labels = list("B","C"), label_size = 24)
FlxEndpPlots

FlxEndpPlots1 <- cowplot::plot_grid(FlxEndpPlots, legend,
                                    rel_widths = c(5,1))

FlxPlots <- cowplot:::plot_grid(DNT60_VC_Plot, FlxEndpPlots1,
                    labels = list("A"), label_size = 24,
                    ncol = 1)
FlxPlots

ggsave(FlxPlots, file='figures/Figure2_overlay_transform_non_transform_maxfluox_ctrl_nov2023.png',
       width=21,
       height=12)

```

#### KC nov 2023: Supplemental Figure 2: Fluoxetine Vehicle Control and 4 uM Treatment Group Raw Endpoint Data
Kelly E carstens modified for the supplemental figure
```{r, plot-endpoint-data-for-smpl, fig.dim=c(10,10), message = FALSE}
# Raw endpoint data for Fluoxetine vehicle control
raw_stats1 <- endp.data_all[wllt=="v", .(mean=mean(rval,na.rm=T),median=median(rval,na.rm=T)), by=.(endp,transform)]

raw_stats1_l <- data.table::melt(raw_stats1, id.vars = c("endp","transform"), variable.name = "stat")

endp.data_allx <- endp.data_all[!(wllt=='v' & endp =='AUC_r' & rval > 15) & !endp == 'avgS_L',]

raw_plot_facet <- ggplot(endp.data_allx[wllt=="v"]) +
                    geom_density(aes(x=rval, fill=as.factor(transform), color = as.factor(transform)), alpha = 0.5) +
                    theme_bw() +
                    theme(text = element_text(size = 16)) +
                    facet_wrap(~endp, scales = "free") +
                    scale_color_manual(values = colors[c(1,5)]) +
                    scale_fill_manual(values = colors[c(1,5)])

raw_plot_facet <- raw_plot_facet + 
                    # geom_vline(data = raw_stats1_l, aes(xintercept=value, linetype=stat), color = rep(colors[c(1,5)],26), size=1) +
                                #scale_linetype_discrete(labels = c("Mean","Median")) +
                                labs(
                                  #title = "Box-Cox Power Transformation, All endpoints",
                                       #color = "Data transformation",
                                       #fill = "Data transformation",
                                       x = "Raw Endpoint Value",
                                       y = "Density")
raw_plot_facet


ggsave(raw_plot_facet, file='figures/Supp_Figure1_data_transform_all_end_nov2023.png',
       width=16,
       height=10)

```

#### Supplemental Table 2: Calculate means and variance for raw endpoint data from Fluoxetine vehicle control and stick into table.

```{r, SPT1-means-var-raw}
sample.endp.stats <- endp.data[wllt=="v", .(mean=mean(rval,na.rm=T), variance=stats::var(rval,na.rm=T)), by=.(endp)]
sample.endp.stats[, `:=` (mean = signif(mean,digits=3), variance = signif(variance,digits=3))]
DT::datatable(sample.endp.stats, colnames=c("Endpoint Abbreviation","Mean","Variance"),
              caption = "Raw Endpoint Data Statistics for DNT60 Screening Vehicle Control")

```

#### KC Nov 2023: Supplemental Table 2: Calculate means and variance for raw endpoint data from Fluoxetine vehicle control and stick into table.
Kelly E Carstens modified for the manuscript.
```{r, SPT1-means-var-raw}
endp.data[wllt=='v', .N, by=endp]

sample.endp.stats <- endp.data_all[wllt=="v", .(mean=mean(rval,na.rm=T), sd=stats::sd(rval,na.rm=T)), by=.(endp,transform)]
sample.endp.stats[, cv := sd/mean * 100]

sample.endp.stats[, `:=` (mean = signif(mean,digits=3), sd = signif(sd,digits=3), cv = signif(cv, digits=3))]

stats1 <- dcast(sample.endp.stats, endp ~ transform, value.var = "mean" )
setnames(stats1, "Non-transformed","Mean_Non_transformed")
setnames(stats1, "Transformed","Mean_Transformed")

stats2 <- dcast(sample.endp.stats, endp ~ transform, value.var = "sd" )
setnames(stats2, "Non-transformed","SD_Non_transformed")
setnames(stats2, "Transformed","SD_Transformed")

stats3 <- dcast(sample.endp.stats, endp ~ transform, value.var = "cv" )
setnames(stats3, "Non-transformed","CV_Non_transformed")
setnames(stats3, "Transformed","CV_Transformed")

sample.endp.stats <- merge(stats1, stats2, by='endp')
sample.endp.stats <- merge(sample.endp.stats, stats3, by='endp')


DT::datatable(sample.endp.stats, colnames=c("Endpoint","Mean","SD"),
              caption = "Data Transformation")

write.csv(sample.endp.stats, 'output/Data_transformation_stats_veh_contorl_Nov2023.csv')

```


#### Supplemental Table 3: Calculate means and variance for transformed endpoint data from Fluoxetine vehicle control and stick into table.

```{r, SPT1-means-var-raw}
sample.endp.stats_n <- endp.data_n[wllt=="v", .(mean=mean(rval,na.rm=T), variance=stats::var(rval,na.rm=T)), by=.(endp)]
sample.endp.stats_n[, `:=` (mean = signif(mean,digits=3), variance = signif(variance,digits=3))]
DT::datatable(sample.endp.stats_n, colnames=c("Endpoint Abbreviation","Mean","Variance"),
              caption = "Transformed Endpoint Data Statistics for DNT60 Screening Vehicle Control")
```

#### Supplemental Table 4: Box-Cox power transformation parameters.

```{r, Box-Cox Parameters}
bxcx.params <- lapply(mc0_n, function(data) {
  as.data.table( data[c(2,3)] )
})

bxcx.params.dt <- do.call('rbind', bxcx.params)
bxcx.params.dt[, endp := names(bxcx.params)]

datatable(bxcx.params.dt[, .(endp,lam.hat,shift)], colnames=c("Endpoint Abbreviation","Lambda","Shift"),
              caption = "Box-Cox Power Transformation Parameters for Endpoints")
```

### Applying tcplFit2

How many chemical-endpoint pair were active? How many chemicals had at least one active endpoint?

```{r, active-chemicals-endpoints}
# Endpoints to exclude
exclude <- c("AUC_L","AUC_D","AUC_T")

# Number of active chemical-endpoint pairs
tcpl_out.dt[hitcall>0.8 & !endp%in%exclude, .N]

# Number of active chemicals
length( tcpl_out.dt[hitcall>0.8 & !endp%in%exclude, unique(name)] )
```

Evaluating popular fits.

```{r, evaluating-popular-fits}
# Popular fits for all endpoint data
tcpl_out.dt[!endp%in%exclude, .N, by = .(fit_method)]

# Popular fits for active curve-fits
tcpl_out.dt[!endp%in%exclude & hitcall>0.8, .N, by = .(fit_method)]
```

Evaluate the the occurrence of developmental toxicity for chemicals fit optimally by the poly1 function.

```{r, evaluate-hits-with-poly1}
# Isolate chemicals with active endpoints optimally fitted by poly1
chemicals <- tcpl_out.dt[hitcall>0.8 & fit_method=="poly1" & !endp%in%c("AUC_L","AUC_D","AUC_T"), unique(name)]

# Is developmental toxicity associated with these chemicals?
litReviewConc[, dev_LOEL := min(.SD[devtox==1,conc]), by=.(cpid)]
litReviewConc[is.infinite(dev_LOEL), dev_LOEL := NA]
litReviewConc[cpid%in%chemicals, .(dev_LOEL = unique(dev_LOEL)), by = .(cpid)]
```

### Activity in Terms of Endpoints

#### Supplemental Table 5: Number of chemicals active in each endpoint.

```{r, number-of-chemicals-active}
count.hits.endp <- tcpl_out.dt[hitcall>0.8 & !endp%in%exclude, unique(name), by = .(endp)][, .N, by = .(endp)]

datatable(count.hits.endp[order(-N)], colnames=c("Endpoint Abbreviation","Number of Active Chemicals"), caption = "Number of Chemicals Active in Each Endpoint",
          rownames = FALSE)
```


#### KC: Activity Summary table and top_over_cutoff plots
Kelly E Carstens created for manuscript.
```{r, active-chemicals-table}
exclude <- c('AUC_L','AUC_D','AUC_T')

# binary hitcall
mc5 <- tcpl_out.dt[!endp %in% exclude,]
mc5[ , hitc := ifelse(hitcall>0.8, 1, 0)]
mc5[hitc==0, bmd := NA]
mc5[hitc==0, top_over_cutoff := NA]

# summary table by aenm
mc5.sum.endp <- mc5[, list(
  hitsum = sum(hitc),
  bmd.med = median(bmd, na.rm=T),
  bmd.mean = mean(bmd, na.rm=T),
  bmd.sd = sd(bmd, na.rm=T)),
  # toc.mean = mean(top_over_cutoff, na.rm=T),
  # toc.sd = sd(top_over_cutoff, na.rm=T)),
  by= endp][order(-hitsum)]

cols <- c('bmd.mean','bmd.sd','bmd.med')
mc5.sum.endp[,(cols) := round(.SD,3), .SDcols=cols]
write.csv(mc5.sum.endp, 'output/Endp_tbl_summary_stat_23Nov23.csv')

# summary table by chemical
mc5.sum <- mc5[, list(
  hitsum = sum(hitc),
  bmd.min = min(bmd, na.rm=T),
  bmd.med = median(bmd, na.rm=T),
  bmd.mean = mean(bmd, na.rm=T),
  bmd.sd = sd(bmd, na.rm=T),
  toc.mean = mean(top_over_cutoff, na.rm=T),
  toc.sd = sd(top_over_cutoff, na.rm=T)),
  by= name]

cols <- c('bmd.min','bmd.med','bmd.mean','bmd.sd','toc.mean','toc.sd')
mc5.sum[,(cols) := round(.SD,2), .SDcols=cols]

max.conc.tbl <- endp.data[, list(max.conc = max(conc)), by=cpid]
mc5.sum$max.conc <- max.conc.tbl$max.conc[match(mc5.sum$name, max.conc.tbl$cpid)]
write.csv(mc5.sum, 'output/Chem_tbl_summary_stat.csv') # table 4

active.hits <- mc5[hitc==1]
nrow(active.hits)
nrow(mc5[top_over_cutoff <1.5,])

high.eff <- active.hits[top_over_cutoff>1.5,]
unique(high.eff$name)

# mean efficacy by endpoint
mc5.eff.sum <- mc5[, list(toc.mean.end = mean(top_over_cutoff, na.rm=T),
                          top.sd.end = sd(top_over_cutoff, na.rm=T)), by=endp]

# regression plot max conc tested
mc5$max.conc <- max.conc.tbl$max.conc[match(mc5$name, max.conc.tbl$cpid)]
mc5[, hitsum := sum(hitc), by=name]

library(ggpubr)
library(ggplot2)
library(ggpmisc)

p1 <- ggscatter(
  mc5, y = "top_over_cutoff" , x = "max.conc",
  #color = variable, palette = "blues",
  add = "reg.line"
  ) +
  # stat_cor(label.y=3.0,
  #          aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~"))) +
  # stat_regline_equation(label.y=2.9)+
  stat_cor(label.y = 3.0) +
  stat_regline_equation(label.y = 2.9)+
  labs(title="Effect size versus maximum concentration tested", 
         x="Maximum Concentration (uM)")
  #y = expression(paste("Mean AC50 (log10 ",mu,"M)")))+
  # ylim(c(-2,3))

p1

lm1 <- lm(max.conc~top_over_cutoff, data = mc5)
summary(lm1)

p2 <- ggscatter(
  mc5[!hitsum==0,], y = "top_over_cutoff" , x = "hitsum",
  #color = "name",
  add = "reg.line"
  ) +
  # stat_cor(label.y=3.0,
  #          aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~"))) +
  # stat_regline_equation(label.y=2.9)+
    stat_cor(label.y = 3.0) +
  stat_regline_equation(label.y = 2.9)+
  labs(title="Effect size versus hit rate by chemical", 
         x="Hit Rate by chemical")

  #y = expression(paste("Mean AC50 (log10 ",mu,"M)")))+
  # ylim(c(-2,3))
p2
lm2 <- lm(hitsum~top_over_cutoff, data = mc5)
summary(lm2)

p.all <- cowplot:::plot_grid(p1, p2,
                    labels = "AUTO", label_size = 24,
                    ncol = 2)
ggsave(p.all, file='figures/fig_supp6_Cowplot_regression_top_over_cutoff.tiff',
       width=11, height=5, dpi=300)

```

## Effect size comparison
Kelly E Carstens created for the manuscript.
```{r, active-chemicals-table}

# histogram plot of the top over cutoff for hits
end.common <- c('avgS_T','avgS_D','avgS_L','AUC_r')
mc5$end.cat <- "Expanded"
mc5[endp %in% end.common, end.cat := "Commonly studied"]
unique(mc5$end.cat)

mc5[hitc==1, median.toc := median(top_over_cutoff), by=endp]


p4 <- ggplot(mc5[hitc==1], aes(x=top_over_cutoff, y=reorder(endp, median.toc), fill=end.cat))+
  geom_boxplot(alpha=0.3)+
  geom_point()+
  #scale_fill_grey()+
    scale_fill_manual(values=c( "#E69F00", "#56B4E9"), name="Endpoint Category")+

    #scale_fill_discrete(name="Endpoint Category")+
  ylab("")+
  theme_classic()+
  ggtitle("Boxplot of effect size by endpoint")+
    theme(
    legend.position = c(.8, .2)
    )+
  theme(text= element_text(size=14))

p4

mc5[hitc==1, median.toc.chem := median(top_over_cutoff), by=name]

mc5.temp <- mc5[name %in% 'Polybrominated diphenyl ether (PBDE)-47', name := 'PBDE-47']
p5 <- ggplot(mc5.temp[hitc==1], aes(x=top_over_cutoff, y=reorder(name, median.toc.chem)))+
  geom_boxplot(alpha=0.3)+
  geom_point(aes(color=end.cat), size=3)+
  guides(fill = "none")+
  scale_color_manual(values=c( "#E69F00", "#56B4E9"), name="Endpoint Category")+
  #scale_color_grey(guide="none")+
  #scale_color_discrete(name="Endpoint Category")+
  ylab("")+
  theme_classic()+
  ggtitle("Boxplot of effect size by chemical")+
  theme(
    legend.position = c(.8, .2)
    )+
  theme(text= element_text(size=14))

p5

# compare top over cutoff to other assay endpoints

# library(tcpl)
# tcplConf(user='_dataminer', pass='pass', #insert user and pass
#          db='prod_internal_invitrodb_v4_1', drvr='MySQL', 
#          host='ccte-mysql-res.epa.gov') #insert host
# 
# # Load mc data
# mean(mc5[hitc==1, top_over_cutoff])
# sd(mc5[hitc==1, top_over_cutoff])
# neuro.asids <- c(20,31)
# neuro.assays <- tcplLoadAeid(val=neuro.asids, fld='asid',add.fld='acid')
# neuro.assays <- neuro.assays[!grep("acute",aenm),]
#mc5.neuro <- tcplPrepOtpt(tcplLoadData(lvl=5,type='mc', fld='aeid',val=neuro.assays$aeid, add.fld=T))
#save(mc5.neuro, file= 'output/ToxCast_dnt_end_mc5_invitrodb_4_1_22Nov23.Rdata')
load('output/ToxCast_dnt_end_mc5_invitrodb_4_1_22Nov23.Rdata')
# chems.match <- as.data.table(unique(mc5$name))
# chems.match$chnm <- mc5.neuro$chnm[match(chems.match$V1, mc5.neuro$chnm)]
library(openxlsx)
#write.xlsx(chems.match, 'output/Map_chems_to_chnm_kelly_22Nov23.xlsx')
chems.match2 <- as.data.table(read.xlsx('output/Map_chems_to_chnm_kelly_22Nov23_edit.xlsx'))
chems.match2$chnm2 <- mc5.neuro$chnm[match(chems.match2$chnm, mc5.neuro$chnm)]

mc5.sub <- mc5.neuro[chnm %in% chems.match2$chnm,]
mc5.sub <- mc5.sub[!is.na(chnm),]
mc5.sub[,  hitc2 := ifelse(hitc>=0.9,1,0)]

mean(mc5.sub[hitc==1, top_over_cutoff])
sd(mc5.sub[hitc==1, top_over_cutoff])
quantile(mc5.sub[hitc==1, top_over_cutoff], 0.95)

mc5.sub$assay <- "Other DNT assays"
mc5$assay <- "Zebrafish assay"
mc5.hist1 <- mc5[, c('name','endp','hitc','top_over_cutoff','assay')]
setnames(mc5.hist1, "name","chnm")
setnames(mc5.hist1, "endp","aenm")
mc5.hist2 <- mc5.sub[, c('chnm','aenm','hitc2','top_over_cutoff','assay')]
setnames(mc5.hist2, "hitc2","hitc")

df.hist <- rbind(mc5.hist1, mc5.hist2)
df.hist$end.cat <- mc5$end.cat[match(df.hist$aenm, mc5$endp)]
df.hist[assay %in% "Other DNT assays", end.cat := "Other DNT assays"]

p6 <- ggplot(df.hist[hitc==1 & top_over_cutoff < 15], aes(x=top_over_cutoff,  fill=end.cat, color=end.cat))+
  geom_density(alpha=0.38, position="identity")+
  #scale_color_grey()+scale_fill_grey() +
  scale_fill_manual(values=c( "#E69F00", "#56B4E9", "#999999"), name="Endpoint Category")+
    scale_color_manual(values=c( "#E69F00", "#56B4E9", "#999999"), name="Endpoint Category")+
  theme_classic()+
  ggtitle("Distribution of effect size")+
    theme(
    legend.position = c(.8, .3)
    )+
  xlim(0,10)+
  theme(text= element_text(size=14))

p6

p.all <- cowplot:::plot_grid(p4, p5, p6,
                    labels = "AUTO", label_size = 20,
                    ncol = 1)
ggsave(p.all, file='figures/Cowplot_top_over_cutoff_histos_long_08April2025.tiff',
       width=8, height=11, dpi=300)


mc5[, modl := fit_method]
model <- lm(top_over_cutoff ~ max.conc + hitsum  +end.cat + modl + bmd, data = mc5[hitc==1])
summary(model)

library(broom)
tidy_lmfit <- tidy(model)
tidy_lmfit
```


#### KC: BMC comparisons
This is not included in the manuscript
```{r, active-chemicals-table}


p1 <- ggscatter(
  mc5, y = "bmd" , x = "max.conc",
  #color = variable, palette = "blues",
  add = "reg.line"
  ) +
  # stat_cor(label.y=3.0,
  #          aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~"))) +
  # stat_regline_equation(label.y=2.9)+
  stat_cor(label.y = 90) +
  stat_regline_equation(label.y = 85)+
  labs(title="Effect size versus maximum concentration tested", 
         x="Maximum Concentration (uM)")
  #y = expression(paste("Mean AC50 (log10 ",mu,"M)")))+
  # ylim(c(-2,3))

p1

lm1 <- lm(max.conc~bmd, data = mc5)
summary(lm1)

p2 <- ggscatter(
  mc5[!hitsum==0,], y = "bmd" , x = "hitsum",
  #color = "name",
  add = "reg.line"
  ) +
  # stat_cor(label.y=3.0,
  #          aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~"))) +
  # stat_regline_equation(label.y=2.9)+
    stat_cor(label.y = 90) +
  stat_regline_equation(label.y = 85)+
  labs(title="Effect size versus hit rate by chemical", 
         x="Hit Rate by chemical")

  #y = expression(paste("Mean AC50 (log10 ",mu,"M)")))+
  # ylim(c(-2,3))
p2

lm2 <- lm(hitsum~bmd, data = mc5)
summary(lm2)


# p3 <- ggplot(mc5[hitc==1], aes(x=bmd, color=end.cat, fill=end.cat))+
#   geom_histogram(alpha=0.5, position="identity")+
#   scale_color_grey()+scale_fill_grey() +
#   theme_classic()+
#   ggtitle("Distribution of 'bmd' values")
# p3

mc5[hitc==1, median.bmd := median(bmd), by=endp]


p4 <- ggplot(mc5[hitc==1], aes(x=log10(bmd), y=reorder(endp, median.bmd), fill=end.cat))+
  geom_boxplot(alpha=0.5)+
  geom_point()+
  #scale_fill_grey()+
    scale_fill_discrete(name="Endpoint Category")+
  ylab("")+
  xlab("BMC (log10-uM)")+
  theme_classic()+
  ggtitle("Boxplot of BMC values by endpoint")+
    theme(
    legend.position = c(.8, .2)
    )+
  theme(text= element_text(size=14))

p4

mc5[hitc==1, median.bmd.chem := median(bmd), by=name]

mc5.temp <- mc5[name %in% 'Polybrominated diphenyl ether (PBDE)-47', name := 'PBDE-47']
p5 <- ggplot(mc5.temp[hitc==1], aes(x=log10(bmd), y=reorder(name, median.bmd.chem)))+
  geom_boxplot(alpha=0.5)+
  geom_point(aes(color=end.cat), size=3)+
  guides(fill = "none")+
  #scale_color_grey(guide="none")+
  scale_color_discrete(name="Endpoint Category")+
  ylab("")+
  xlab("BMC (log10-uM)")+
  theme_classic()+
  ggtitle("Boxplot of BMC values by chemical")+
  theme(
    legend.position = c(.8, .2)
    )+
  theme(text= element_text(size=14))

p5

# compare bmc to other assay endpoints

mc5.sub[hitc2==0, bmd := NA]
mean(mc5.sub[hitc2==1, bmd,], na.rm=T)
sd(mc5.sub[hitc2==1, bmd], na.rm=T)
quantile(mc5.sub[hitc2==1, bmd], 0.95, na.rm=T)

mc5.sub$assay <- "Other DNT assays"
mc5$assay <- "Zebrafish assay"
mc5.hist1 <- mc5[, c('name','endp','hitc','bmd','assay')]
setnames(mc5.hist1, "name","chnm")
setnames(mc5.hist1, "endp","aenm")
mc5.hist2 <- mc5.sub[, c('chnm','aenm','hitc2','bmd','assay')]
setnames(mc5.hist2, "hitc2","hitc")

df.hist <- rbind(mc5.hist1, mc5.hist2)

p6 <- ggplot(df.hist[hitc==1 & bmd <100], aes(x=log10(bmd), color=assay, fill=assay))+
  geom_density(alpha=0.38, position="identity")+
  #scale_color_grey()+scale_fill_grey() +
  theme_classic()+
  ggtitle("Distribution of 'bmd' values")+
    theme(
    legend.position = c(.8, .2)
    )+
  theme(text= element_text(size=14))

p6

# 
# p.all <- cowplot:::plot_grid(p4, p5, p6,
#                     labels = "AUTO", label_size = 20,
#                     ncol = 1)
# ggsave(p.all, file='figures/Cowplot_bmd_histos_long.tiff',
#        width=11, height=16, dpi=300)


```

#### KC edit Figure 3: Count of Active Chemicals by Phase and Endpoint Category

```{r, active-by-category-phase, fig.dim=c(20,10)}

# map in new activity type categories as of 23 Nov 2023
#endp.out <- data.frame(unique(mc5[, c('endp','end.cat')]))
#write.csv(endp.out, 'output/Endpoint_tbl_list.csv')
endp.in <- as.data.table(read.csv('output/Endpoint_tbl_list_edit_in_23Nov23.csv'))
endp.in$X <- NULL
mc5 <- merge(mc5, endp.in, by=c('endp'))

unique(mc5[, c('endp','Activity.Type','Experimental.Phase')])

#---------------------------------------------------------------------------#
#KC: Try using the complex upset plot
#---------------------------------------------------------------------------#
# setup data table
hits1 <- unique(mc5[hitc==1,c('name','Activity.Type')])
hits1$hit <- 1
dat2 <- dcast(hits1, name ~ Activity.Type, value.var = "hit")
dat2$name <- NULL
dat2[is.na(dat2)] <- 0
dat2[] <- lapply(dat2, as.logical)


library(ComplexUpset)
pipes <- colnames(dat2)
nrow(dat2)

plot1 <- upset(data = dat2, intersect = pipes, 
              name= "Concordance by Activity Type", 
              width_ratio = 0.125,
              set_sizes=(
        upset_set_size()
        + theme(axis.text.x=element_text(angle=90))
    ))
plot1

#save to file
file.dir <- paste("./figures/", sep="")
file.name <- paste("/fig_upset_plot_activity_type", Sys.Date(), ".png", sep="")
file.path <- paste(file.dir, file.name, sep="")
dir.create(path=file.dir, showWarnings = FALSE, recursive = TRUE)
png(file.path,
    width = 11,
    height = 4.8, #change from 8 to 20
    units = "in",
    res = 300)
plot1
dev.off()

#---------------------------------------------------------------------------#
#KC: Try using the complex upset plot; experimental phase
#---------------------------------------------------------------------------#
# setup data table
hits1 <- unique(mc5[hitc==1,c('name','Experimental.Phase')])
hits1$hit <- 1
dat2 <- dcast(hits1, name ~ Experimental.Phase, value.var = "hit")
dat2$name <- NULL

library(ComplexUpset)
pipes <- colnames(dat2)
nrow(dat2)
plot2 <- upset(data = dat2, intersect = pipes, 
              name= "Concordance by Experimental Phase", 
              min_size = 0,
              width_ratio = 0.125,
              set_sizes=(
        upset_set_size()
        + theme(axis.text.x=element_text(angle=90))
    ))
plot2

p.all <- cowplot::plot_grid(plot1, plot2, scale=0.95,
                            rel_widths = c(9,7),
                   labels = "AUTO", label_size = 20)
p.all
ggsave(p.all, file='figures/Cowplot_upset_plot_A_B.tiff',
       width=12, height=5, dpi=300)

```      


#### BMC Heatmap to be displayed later.
Note from KEC: could not successfully run this code by Zach Rowson to regenerate the heatmap.
```{r, load-BMC-data}
# ac <- c("avgS_L", "hbt1_L", "hbt2_L","RoA_L",
#         "strtlA","strtlAavg", "strtlF",
#         "avgS_D","hbt1_D", "hbt2_D", "RoA_D",
#         "avgS_T","AUC_r")
# 
# tcplfits_n <- mc5 
# tcplfits_n$chm <- tcplfits_n$name
# tcplfits_n <- tcplfits_n[hitc==1,]
# tcplfits_n[, bmd := log10(bmd)]
# bmc <- dcast(tcplfits_n, chm ~ endp, value.var = 'bmd')
# bmc[is.na(bmc)] <- log10(10000)

```
```{r, layer-matrix}
# Create a matrix specifying if an up, down, up and down, or down and up arrow should be printed in cells.

# layer.mat <- lapply(tcplfits_n, function(chm) unlist(lapply(chm, function(fit) {
#                 hitcall <- fit[["summary"]]$hitcall
#                 fit_method <- fit[["summary"]]$fit_method
#                 dir <- sign(fit[["summary"]]$top)
#                 if (hitcall>0.8 & fit_method=="gnls" & dir==1) {
#                   layer <- 0
#                 } else if (hitcall>0.8 & fit_method=="gnls" & dir==-1) {
#                   layer <- 1
#                 } else if (hitcall>0.8 & dir==1) {
#                   layer <- 2
#                 } else if (hitcall>0.8 & dir==-1) {
#                   layer <- 3
#                 } else layer <- 4
#               })))

# layer.mat <- do.call("rbind", layer.mat)
# rownames(layer.mat)[50] <- "PBDE-47" # Change PBDE-47 name to match BMD matrix
# layer.mat1 <- layer.mat[row.names(layer.mat) %in% actives,]

# Change rownames to include the number of active endpoints per chemical
# to.fit.rownames <- tcpl_out.dt[hitcall>0.8, .N, by=.(name)][, paste0(name," (",N,")")]
# to.fit.rownames[19] <- "PBDE-47 (5)"

# rownames(layer.mat1) <- to.fit.rownames
```
```{r, heatmap-legends-labels, warning=FALSE}
# Column labels
# col_labels <- c(expression("Average Speed in Light"^1), "Habiutation 1 in Light", "Habituation 2 in Light", expression("Range of Activity in Light"),
#                 "Startle Acceleration", "Startle Relative to Avg. Speed in Light", "Startle Fold-Change",
#                 expression("Average Speed in Dark"^1), "Habituation 1 in Dark", "Habituation 2 in Dark", expression("Range of Activity in Dark"),
#                 "Average Speed in Both Phases", expression("AUC in Dark / AUC in Light Ratio"^2)) # Superscripts notate references in poster
# # Legends
# 
# # Custom heat legend.
# library(circlize)
# f2 = circlize::colorRamp2(seq(min(bmc), max(bmc), length = 8), rev(viridis(8)), space = "sRGB")
# heat_lgd = Legend(col_fun = f2,
#                   title = paste0("BMC log(","\U03BC","M)"),
#                   title_position = "lefttop",
#                   legend_width = unit(4,"cm"),
#                   direction = "horizontal")
# # Column annotation by phase legend.
# ann_lgd = Legend(labels = c("Light","Transition","Dark","Light+Dark"),
#                  title = "Phase",
#                  title_position = "leftcenter",
#                  labels_gp = gpar(fontsize=8),
#                  title_gp = gpar(fontsize=8),
#                  legend_gp = grid::gpar(fill = c("white","grey","black","red")),
#                  border = TRUE,
#                  nrow = 1,
#                  column_gap = unit(5, 'mm'))
# # Legend for cell signal arrows.
# dir_lgd = Legend(labels = c(paste("\U2191","Gain"),
#                             paste("\U2193","Loss"),
#                             paste("\U21C5","GainLoss"),
#                             paste("\U21F5","LossGain")),
#                  title = "Signal Direction",
#                  labels_gp = gpar(fontsize=8),
#                  title_gp = gpar(fontsize=8),
#                  title_position = "leftcenter",
#                  nrow = 1,
#                  column_gap = unit(0, 'mm')) # Will produce warnings, don't worry.
# lgd_list <- packLegend(ann_lgd, dir_lgd)
# 
# # Create column annotation indicating the phase of the LMR that is described.
# column_ha <- ComplexHeatmap::HeatmapAnnotation(Phase = factor(c(rep("Light",4), rep("Transition",3),rep("Dark",4),rep("Light+Dark",2)),
#                                                         levels=c("Light","Transition","Dark","Light+Dark")),
#                                                border = TRUE,
#                                                simple_anno_size = unit(0.25, 'cm'),
#                                                col = list(Phase=c("Light"="white",
#                                                                   "Transition"="grey",
#                                                                   "Dark"="black",
#                                                                   "Light+Dark"="red")),
#                                                annotation_legend_param = list(nrow = 1),
#                                                show_annotation_name = FALSE,
#                                                show_legend = FALSE)
# 
# # Create function to add arrows indicating signal direction in cells.
# cell_fun <- function(j, i, x, y, width, height, fill) {
#   if (layer.mat1[i,j] == 0) {
#     grid.text("\U21C5", x, y, gp=gpar(fontsize=8))
#   } else if (layer.mat1[i,j] == 1) {
#     grid.text("\U21F5", x, y, gp=gpar(fontsize=8))
#   } else if (layer.mat1[i,j] == 2) {
#     grid.text("\U2191", x, y, gp=gpar(fontsize=8))
#   } else if (layer.mat1[i,j] == 3) {
#     grid.text("\U2193", x, y, gp=gpar(fontsize=8))
#   }
# }
# ```
# ```{r, heatmap, warning=FALSE, fig.dim=c(8,8)}
# # isolate data for heatmap
# to.fit <- bmc[row.names(bmc) %in% actives,]
# rownames(to.fit) <- to.fit.rownames
# 
# # Create main heat map.
# htlist <- ComplexHeatmap::Heatmap(to.fit,
# 
#                         # Specify some parameters for heat legend.
#                         name = paste0("BMC log(","\U03BC","M)"),
#                         col = f2,
#                         border_gp = grid::gpar(col="black",lwd=1),
#                         rect_gp=grid::gpar(col="grey"),
#                         show_heatmap_legend = TRUE,
#                         heatmap_legend_param = list(legend_height = unit(3.5,"cm"),
#                                                     direction = "vertical",
#                                                     title_gp = grid::gpar(fontsize=10),
#                                                     labels_gp = grid::gpar(fontsize=10)),
# 
#                         # Heatmap width and height
#                         # width = unit(16,"in"),
#                         # height = unit(18,"in"),
# 
#                         # Column label parameters
#                         column_labels = col_labels, column_names_rot = 45,
# 
# 
#                         # Split columns by phase.
#                         column_split = factor(c(rep("Light",4), rep("Transition",3),rep("Dark",4),rep("Light+Dark",2)),
#                                               levels=c("Light","Transition","Dark","Light+Dark")),
# 
#                         # Specify some column parameters.
#                         column_title = NULL,
#                         top_annotation = column_ha,
# 
#                         # Add signal direction arrows.
#                         cell_fun = cell_fun,
# 
#                         # Specify some parameters row dendrogram aesthetics and row labels.
#                         row_title_side = "right",
#                         row_title_rot = 0,
#                         row_split = 5,
#                         row_dend_side = "right",
#                         row_names_side = "left",
# 
#                         # Clustering parameters.
#                         cluster_columns = FALSE,
#                         cluster_rows = TRUE,
#                         clustering_distance_rows = "pearson",
# 
#                         # Font sizes
#                         row_names_gp = grid::gpar(fontsize=10),
#                         column_names_gp = grid::gpar(fontsize=10),
#                         row_title_gp = grid::gpar(fontsize=10),
#                         column_title_gp = grid::gpar(fontsize=10)
#                         )
```


# KC supp: winning model bar chart

```{r, winning model}

mc5[hitc==1, order.fit := .N, by=fit_method]

p1 <- ggplot(mc5[hitc==1], aes(x=reorder(fit_method, order.fit)))+
  geom_bar(width=0.8, fill='darkgrey',color="black")+
  stat_count(geom = "text", colour = "black", size = 5,
              aes(label = paste(..count..,"57",sep="/")), vjust=-0.5)+
  theme_classic()+
    labs(title="Winning concentration-response models",
         #y="Hits", 
         x=NULL)+
      theme(text= element_text(size=18))+
    theme(plot.title=element_text(size=16))
p1
ggsave(p1, file='figures/Winning_model_bar_plot_24Nov23.tiff',
       dpi=300, width=8, height=6)

```


## Supplemental Tables
```{r  results= "hide", warning=FALSE, message=FALSE}

library(openxlsx)
read.me <- read.xlsx('input/README_supplementals.xlsx')
chem.tbl <- read.xlsx('input/Chemical_table_edit_16Nov23.xlsx')

list.supp <- list('README'= read.me,
                  'SuppTb1'=chem.tbl,
                  'SuppTb2'=tcpl_out.dt,
                  'SuppTb3'=mc5.sub,
                  'SuppTb4'=bxcx.params.dt,
                  'SuppTb5'=tidy_lmfit
                  # 'SuppTb4'=df.sum
                  )

write.xlsx(list.supp, file='./output/Supp_tbls_manuscript_24Nov2023.xlsx', overwrite=TRUE)

```
